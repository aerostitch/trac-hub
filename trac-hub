#!/usr/bin/env ruby

require 'json'
require 'logger'
require 'octokit'
require 'optparse'
require 'sequel'
require 'yaml'
require 'set'
require 'singleton'
require 'uri'

class GracefulQuit
  include Singleton

  attr_accessor :breaker

  def initialize
    self.breaker = false
  end

  def self.enable
    trap('INT') {
      yield if block_given?
      self.instance.breaker = true
    }
  end

  def self.check(message = "Quitting")
    if self.instance.breaker
      yield if block_given?
      puts message
      exit
    end
  end

end

class Migrator
  def initialize(trac, github, users, labels, revmap, attachurl)
    @trac = trac
    repo = github['repo']
    $logger.info('Retrieving e-mails for users with a valid login')
    @client = GitHub.new(github["user"], github["pass"], repo)

    @users = Hash[users]
    @labels = Hash[labels.map { |cat, rx| [cat, Hash[rx] ] }]
    @ticket_to_issue = {}
    @trac_mails_cache = Hash.new
    @last_created_issue = @client.list_issues.map { |i| i[:number] }.max
    # Initialize to '0' if no ticket exist yet.
    if @last_created_issue == nil
        @last_created_issue = 0
    end
    @revmap = revmap
    @attachurl = attachurl
    $logger.info("Last created issue on GitHub is '#{@last_created_issue}'")
  end

  def migrate(start_ticket = -1)
    if start_ticket == -1
      start_ticket = @last_created_issue+1
    end
    GracefulQuit.enable
    migrate_tickets(start_ticket)
  end

  private

  # returns the author mail if found, otherwise author itself
  def trac_mail(author)
    return @trac_mails_cache[author] if @trac_mails_cache.has_key?(author)
    # tries to retrieve the email from trac db
    data = @trac.sessions.select(:value).where('name = "email" AND sid = ?', author)
    return (@trac_mails_cache[author] = data.first[:value]) if data.count == 1
    return (@trac_mails_cache[author] = author) # not found
  end

  # returns the git commit hash for a specified revision (using revmap hash)
  def map_changeset(str)
    if @revmap and @revmap.has_key?(str)
      return "[r#{str}](../commit/#{@revmap[str]})"
    else
      return str
    end
  end

  # Creates github issues for trac tickets.
  def migrate_tickets(start_ticket)
    $logger.info('migrating issues')
    # We match the issue title to determine whether an issue exists already.
    @trac.tickets.order(:id).where{id >= start_ticket}.all.each do |ticket|

      begin
        # issue exists already:
        issue = @client.issue(ticket[:id])
        $logger.info("found ticket #{ticket[:id]}")
      rescue

        # create issue:
        author = trac_mail(ticket[:reporter])
        title = ticket[:summary]
        body, labels = get_ticket_body(ticket)
        $logger.info("creating issue #{ticket[:id]} (#{ticket[:reporter]} => #{author})")
        issue = @client.create_issue(title, body, {:labels => labels})
        $logger.info("created issue ##{issue[:number]} for ticket #{ticket[:id]}")

        # close issue if needed:
        if ticket[:status] == "closed"
          $logger.info("issue #{issue[:number]}: closing")
          @client.close_issue(issue[:number])
        end

        # assert correct issue number
        if issue[:number] != ticket[:id]
          $logger.info("mismatch issue ##{issue[:number]} for ticket #{ticket[:id]}")
          exit 1
        end
        @last_created_issue = issue[:number]
        GracefulQuit.check("quitting after completing #{@last_created_issue}")
      end
    end
  end

  def get_ticket_body(ticket)

    body = ""
    body += "*Issue migrated from trac ticket # #{ticket[:id]}*\n\n"

    # summary line:
    body += [:component, :priority, :resolution, :keywords].map{
        |cat| ticket[cat] and not ticket[cat].lstrip.empty? and
              "**#{cat.to_s}:** #{ticket[cat]}"
    }.select{|x| x}.join(" | ")

    # Initial report
    # TODO: respect ticket[:changetime]
    body += ticket_change({
      ticket: ticket[:id],
      time: ticket[:time],
      author: ticket[:reporter],
      field: "comment",
      oldvalue: nil,
      newvalue: ticket[:description],
    })

    # combine the changes and attachment table results and sort them by date
    changes = @trac.changes.where(:ticket => ticket[:id]).collect.to_a
    changes += @trac.attachments.where(:type => 'ticket', :id => ticket[:id]).collect.to_a
    changes = changes.sort_by{|x| x[:time]}

    # replay all changes in chronological order:
    body += changes.map{
      |x| ticket_change(x)
    }.select{|x| x}.join("\n")

    labels = Set[]
    changes.each do |x|
      del = @labels.fetch(x[:field], Hash[])[x[:oldvalue]]
      add = @labels.fetch(x[:field], Hash[])[x[:newvalue]]
      labels.delete(del) if del
      labels.add(add) if add
    end

    return body, labels.to_a.join(",")
  end

  def ticket_change(meta)

    # kind
    if meta[:ticket]
      kind = meta[:field]
    else
      kind = 'attachment'
    end
    kind = 'title' if kind == 'summary'

    # time
    time = meta[:time]
    time = Time.at(time/1e6, time%1e6)

    # author
    author = meta[:author]
    author = trac_mail(author)
    if @users.has_key?(author)
      author = "@" + @users[author]
    end

    text = "\n___\n"
    text += "#### #{time.strftime("%Y-%m-%d %H:%M:%S")}: #{author} "

    case kind
      when 'owner', 'status', 'title', 'resolution', 'priority', 'component', 'type', 'severity', 'platform'
        old = meta[:oldvalue]
        new = meta[:newvalue]
        if old and new
          text += "changed #{kind} from *#{old}* to *#{new}*"
        elsif old
          text += "removed #{kind} (was *#{old}*)"
        elsif new
          text += "set #{kind} to *#{new}*"
        end

      when 'comment'
        body = meta[:newvalue]
        text += "commented\n\n"
        text += markdownify(body)
        return '' if body == nil or body.lstrip.empty?

      when 'attachment'
        text += "uploaded file "
        name = meta[:filename]
        body = meta[:description]
        if @attachurl
          url = URI.escape("#{@attachurl}/#{meta[:id]}/#{name}")
          text += "[`#{name}`](#{url})"
          if [".png", ".jpg", ".gif"].include? File.extname(name).downcase
            body += "\n![#{name}](#{url})"
          end
        else
          text += "`#{name}`"
        end
        text += " (#{(meta[:size]/1024.0).round(1)} KiB)"
        text += "\n\n" + body

      when 'description'
        # (ticket[:description] already contains the new value,
        # so there is no need to update)
        text += "edited the issue description"

      when 'keywords', 'cc', 'reporter', 'version'
        # don't care
        return ''
    end

    return text
  end

  def markdownify(str)
    # Line endings
    str.gsub!("\r\n", "\n")
    # CommitTicketReference
    str.gsub!(/\{\{\{\n(#!CommitTicketReference .+?)\}\}\}/m, '\1')
    str.gsub!(/#!CommitTicketReference .+\n/, '')
    # Code
    str.gsub!(/\{\{\{([^\n]+?)\}\}\}/, '`\1`')
    str.gsub!(/\{\{\{(.+?)\}\}\}/m, '```\1```')
    str.gsub!(/(?<=```)#!/m, '')
    # Headings
    str.gsub!(/\=\=\=\=\s(.+?)\s\=\=\=\=/, '#### \1')
    str.gsub!(/\=\=\=\s(.+?)\s\=\=\=/, '### \1')
    str.gsub!(/\=\=\s(.+?)\s\=\=/, '## \1')
    str.gsub!(/\=\s(.+?)\s\=[\s\n]*/, '# \1')
    # Links
    str.gsub!(/\[(http[^\s\[\]]+)\s([^\[\]]+)\]/, '[\2](\1)')
    str.gsub!(/\!(([A-Z][a-z0-9]+){2,})/, '\1')
    # Font styles
    str.gsub!(/'''(.+?)'''/, '**\1**')
    str.gsub!(/''(.+?)''/, '*\1*')
    str.gsub!(/[^:]\/\/(.+?[^:])\/\//, '_\1_')
    # Lists
    str.gsub!(/(^\s+)\*/, '\1-')
    str.gsub!(/(^\s+)(\d)\./, '\1\2.')
    # Changeset
    str.gsub!(/https?:\/\/svnweb.cern.ch\/trac\/madx\/changeset\/(\d+)\/?/, '[changeset:\1]')
    str.gsub!(/\[changeset:"r(\d+)".*\]/, '[changeset:\1]')
    str.gsub!(/\[changeset:r(\d+)\]/,     '[changeset:\1]')
    str.gsub!(/\[changeset:"(\d+)".*\]/) { map_changeset(Regexp.last_match[1]) }
    str.gsub!(/\[changeset:(\d+)\]/)     { map_changeset(Regexp.last_match[1]) }
    str.gsub!(/\br(\d+)\b/)              { map_changeset(Regexp.last_match[1]) }
    # Ticket
    str.gsub!(/ticket:(\d+)/, '#\1')
    return str
  end
end

class Trac
  attr_reader :tickets, :changes, :sessions, :attachments
  def initialize(db)
    $logger.info('loading tickets')
    @db = db
    @tickets = @db[:ticket]
    @changes = @db[:ticket_change]
    @sessions = @db[:session_attribute]
    @attachments = @db[:attachment]
  end
end

class GitHub
  def initialize(user, pass, repo)
    @user = user
    $logger.debug("#{@user} connects to github repo '#{repo}'")
    Octokit.auto_paginate = true
    @client = Octokit::Client.new(:login => @user, :password => pass)
    @repo = repo
  end

  def issue(*args)
    rate_check
    @client.issue(@repo, *args)
  end

  def list_issues
    $logger.debug("#{@user} fetches all open issues in #{@repo}")
    open = fetch_pagewise { |i| @client.list_issues(@repo, :page => i) }
    closed = fetch_pagewise do |i|
      rate_check
      @client.list_issues(@repo, {:state => 'closed', :page => i})
    end
    open + closed
  end

  def create_issue(*args)
    $logger.debug("#{@user} creates issue '#{args[0]}'")
    if args[1].size > 2**16
      msg = "\n\n*(issue truncated due to size)*"
      $logger.warn("truncating issue '#{args[0]}' (#{args[1].size} bytes)")
      args[1] = args[1][0, 65300] + msg
    end
    begin
      rate_check
      @client.create_issue(@repo, *args)
    rescue Octokit::AbuseDetected
      delay = 15
      $logger.warn("Github abuse detection triggered. Retrying in #{delay} min...")
      sleep delay*60
      retry
    rescue
      $logger.error("problem creating issue.")
    end
  end

  def close_issue(*args)
    begin
      rate_check
      @client.close_issue(@repo, *args)
    rescue Octokit::AbuseDetected
      delay = 15
      $logger.warn("Github abuse detection triggered. Retrying in #{delay} min...")
      sleep delay*60
      retry
    rescue
      $logger.error("issue #{args[0]}: can't close issue.")
    end
  end

  private

  def fetch_pagewise
    result = []
    begin
      i = 1;
      loop do
        $logger.debug("fetching page #{i}")
        page = yield i
        break if page.empty?
        result += page
        i += 1
      end
    end
    $logger.debug("fetched #{result.size} elements")
    result
  end

  def rate_check
    limit = @client.rate_limit.limit
    remaining = @client.rate_limit.remaining
    $logger.debug("#{remaining}/#{limit} operations available. Resets in: #{@client.rate_limit.resets_in}s")
    while @client.rate_limit.remaining < 100
      $logger.info("less than #{bound} operations viable, sleeping (#{@client.rate_limit.resets_in}s)...")
      sleep 10
    end
  end
end

class Options < Hash
  def initialize(argv)
    super()
    opts = OptionParser.new do |opts|
      opts.banner = "#{$0}, available options:"
      opts.on('-c config', '--config', 'set the configuration file') do |c|
        self[:config] = c
      end
      opts.on_tail('-h', '--help', 'display this help and exit') do |help|
        puts(opts)
        exit
      end
      opts.on('-s', '--start-at ID', 'start migration from ticket with number <ID>') do |id|
        self[:start] = id
      end
      opts.on('-r', '--rev-map-file FILE',
              'allows to specify a commit revision mapping FILE') do |file|
        self[:revmapfile] = file
      end
      opts.on('-a', '--attachment-url URL',
              'if attachment files are reachable via a URL we reference this here') do |url|
        self[:attachurl] = url
      end
      begin
        opts.parse!(argv)
        if not self[:config]
          default = File.join(File.dirname(__FILE__), 'config.yaml')
          raise 'missing configuration file' unless File.exists?(default)
          self[:config] = default
        end
        self[:start] = -1 unless self[:start]
      rescue => e
        STDERR.puts(e)
        STDERR.puts('run with -h to see available options')
        exit 1
      end
    end
  end
end

if __FILE__ == $0
  opts = Options.new(ARGV)
  cfg = YAML.load_file(opts[:config])

  # Setup logger.
  $logger = Logger.new(STDERR)
  $logger.level = opts[:verbose] ? Logger::DEBUG : Logger::INFO
  $logger.formatter = proc do |severity, datetime, progname, msg|
    time = datetime.strftime('%Y-%m-%d %H:%M:%S')
    "[#{time}] #{severity}#{' ' * (5 - severity.size + 1)}| #{msg}\n"
  end

  # Setup database.
  db = nil
  if db_url = cfg['trac']['database']
    db = Sequel.connect(db_url)
  end
  if not db
    $logger.error('could not connect to trac databse')
    exit 1
  end

  # load revision mapping file and convert it to a hash.
  # This revmap file allows to map between SVN revisions (rXXXX)
  # and git commit sha1 hashes.
  revmap = nil
  if opts[:revmapfile]
    File.open(opts[:revmapfile], "r") do |f|
      $logger.info(opts[:revmapfile])
      revmap = Hash[f.lines
        .map {|line|    line.split(/\s+/)}
        .map {|rev,sha| [rev.gsub(/^r/, ''), sha]}  # remove leading "r" if present
      ]
    end
  end

  trac = Trac.new(db)
  migrator = Migrator.new(trac, cfg['github'], cfg['users'], cfg['labels'], revmap, opts[:attachurl])
  migrator.migrate(opts[:start])
end
